package fr.inria.plugins.construction;

import fr.inria.core.ConstructionStep;
import fr.inria.core.FileUtils;
import fr.inria.core.Project;
import fr.inria.core.Result;
import fr.inria.core.YamlParsing.IncorrectYAMLInformationException;
import fr.inria.utils.StreamGobbler;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.File;
import java.util.*;

public class ExploitTest extends ConstructionStep {
    File jsonMap;
    String mutant;
    String version;
    Map<String,Set<String>> depToTest = new HashMap<>();
    boolean isObliviousToPreviousFailure = false;

    public ExploitTest(Map<String, String> conf, String name) throws IncorrectYAMLInformationException {
        super(conf, name);
        jsonMap = new File(FileUtils.getPropertyOrFail(conf, "testMap"));
        try {
            JSONObject o = FileUtils.readJSONFile(jsonMap);
            Iterator<String> it = o.keys();
            while(it.hasNext()) {
                String s = it.next();
                JSONArray ar = o.getJSONArray(s);
                Set<String> set = new HashSet<>();
                for(int i = 0; i < ar.length(); i++) {
                    set.add(ar.getString(i));
                }
                depToTest.put(s,set);
            }
        } catch (JSONException e) {
            e.printStackTrace();
        }
        if(conf.containsKey("oblivious")) {
            isObliviousToPreviousFailure = conf.get("oblivious").equalsIgnoreCase("true");
        }
    }

    @Override
    public String getType() {
        return "exploit-test";
    }

    @Override
    public boolean isObliviousToPreviousFailure() {
        return isObliviousToPreviousFailure;
    }

    @Override
    public Result run(File dir) {
        Result result = new Result(0, "ok");
        System.out.println("Run '" + getName() + "' in " + dir.getAbsolutePath());

        JSONObject object = null;
        try {
            object = FileUtils.readJSONFile(new File(Project.getInstance().getTmpRoot(), FileUtils.getPropertyOrFail(conf, "mutant")));
            mutant = object.getString("group") + "." + object.getString("artifact");
            version = object.getString("version");
        } catch (JSONException e) {
            e.printStackTrace();
        } catch (IncorrectYAMLInformationException e) {
            e.printStackTrace();
        }

        Runtime rt = Runtime.getRuntime();
        if(depToTest.containsKey(mutant)) {
            for(String lib : depToTest.get(mutant)) {
                try {
                    String[] run = {"/home/nharrand/Documents/exploit/run2.sh", lib, mutant + ":" + version};
                    Process pr = rt.exec(run, null, dir);
                    StreamGobbler errorGobbler = new StreamGobbler(pr.getErrorStream());
                    StreamGobbler outputGobbler = new StreamGobbler(pr.getInputStream());
                    errorGobbler.start();
                    outputGobbler.start();
                    int status = pr.waitFor();
                    result = new Result(status, errorGobbler.getOutput());

                } catch (Exception e) {
                    result = new Result(-1, e.getMessage());
                    e.printStackTrace();
                }
            }
        }
        return result;
    }
}
